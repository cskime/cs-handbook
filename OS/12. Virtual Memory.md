# 가상 메모리

- 사용하는 메모리가 실제 메모리 용량보다 더 많아 보이게 하는 기술
- 한정적인 메모리 공간을 효율적으로 사용하기 위해, **실제로 process에서 실행되고 있는 메모리만 물리 메모리에 올려서 실행**
- Process는 가상의 주소를 사용하고, 실제로 사용되는 주소의 코드만 물리 메모리에 올려서 실행시킨다.
    - 가상 주소(Virtual Address) : Process가 참조하는 주소
    - 물리 주소(Physical Address) : 실제 메모리(RAM) 주소
    - 프로세스는 **4GB의 가상 메모리** 공간에 할당하고, **실제로 CPU가 실행하려는 주소**만 물리 메모리(RAM)에 넣는다.
    - CPU는 먼저 가상 메모리에 접근을 요청해서 **가상 주소**를 찾고, 내부적으로 이를 실제 물리 주소로 변환하여 코드를 실행한다.
        - 가상 주소를 물리 주소로 변환할 때 **'MMU(Memory Management Unit)'**을 사용한다.

<img src="/OS/resources/virtual-memory-executing-process.png" width="50%">

## 가상 메모리를 사용하는 이유

- Process가 실제 물리 메모리를 사용하기에는 너무 작다.
    - Linux는 process당 4GB 할당
    - 실제 물리 메모리는 많아야 32~64GB 수준, 일반적으로 8~16GB
    - 물리 메모리가 6GB라고 가정하면, process A를 실행시킬 동안 process B는 실행시키지 못한다.
- **적은 메모리 용량으로 여러 process를 효율적으로 실행시킬 수 있는 방법**이 필요하다.

가상 메모리를 사용하여 아래 문제를 해결할 수 있다.

1. 메모리 용량 부족 이슈 : 물리 메모리 크기가 작아도 여러 프로세스를 같이 실행시킬 수 있다.
2. 프로세스 간 메모리 영역 침범 이슈 : 각 프로세스는 독립된 가상 메모리 공간을 할당받으므로, 서로의 영역을 침범하지 않는다.
    - 프로세스가 물리 메모리를 할당받는다면, 둘 이상의 프로세스가 같은 주소를 참조하려는 경우가 생길 수 있다.

## MMU(Memory Management Unit)

<img src="/OS/resources/virtual-memory-mmu.png" width="50%">

- CPU에서 가상 메모리 주소에 접근할 때, 이를 해당 물리주소 값으로 빠르게 변환해 주는 하드웨어 장치
- CPU는 다음 순서를 거쳐 실제 코드를 실행시킨다.
    1. 가상 메모리 주소로 접근
    2. MMU를 통해 매칭되는 물리 메모리 주소로 변환
    3. 물리 메모리에서 변환된 주소로 접근
    4. 코드 실행

### 가상 주소를 변환할 때 하드웨어 장치를 사용하는 이유

- CPU가 프로세스를 실행할 때 매번 가상 메모리에 접근해서 물리 주소로 변환 후 코드를 실행하므로, **변환 속도가 빨라야 한다.**
- 즉, **가상 주소를 물리 주소로 변환하는 속도를 높이기 위해** 별도의 하드웨어 장치를 사용한다.

> CPU는 가상 메모리를 다루고, MMU를 통해 가상 메모리에 요청한 가상 주소를 물리 주소로 변환하여 메모리에 접근한다.